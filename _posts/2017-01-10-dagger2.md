---
layout: post
title:  "Dagger 2 依赖注入"
date:   2017-01-10 16:25:42 +0800
categories:  技术
tags: dagger2
---

## 一、控制反转 — Inversion of Control

我们都知道，在采用面向对象方法设计的软件系统中，它的底层实现都是由N个对象组成的，所有的对象通过彼此的合作，最终实现系统的业务逻辑。

对象之间的耦合关系是无法避免的，也是必要的，这是协同工作的基础。

如何降低系统之间、模块之间和对象之间的耦合度，是软件工程永远追求的目标之一。为了解决对象之间的耦合度过高的问题，软件专家```Michael Mattson```提出了```IoC```理论，用来实现对象之间的“解耦”。

```IoC```
体现了好莱坞原则，即“不要打电话过来，我们会打给你”。

所谓的“控制反转”概念就是对组件对象控制权的转移，从程序代码本身转移到了外部容器。

其主要实现方式有两种：

* 依赖查找 ， 故名思义，通过查找来解决依赖关系，```JavaEE```中最常见，```JNDI```（Java  Naming  and Directory Interface）

* 依赖注入，通过容器将业务对象注入到组件中，是最常见的```IoC```类型，最著名的是```Spring```框架，另外还有```Dagger```，其实平常我们也会接触到依赖注入，比如
构造器注入、```setter injection```

关键是，调用者需要的另一个对象实例不在调用者内部实现，而是通过一定的方式从外部传入实例，从而解决了各个类之间的耦合。

## 二、Dagger
* Dagger1
由```Square```开发、通过预编译和反射的手段达到依赖注入的目的，反射会带来的问题：效率降低、无法跟踪调试，代码不能混淆

* Dagger2
被```Google```接管、保留了预编译，取消了反射，更好的性能，官方声称提高3%，方便跟踪调试，可以混淆


## 三、Dagger2的四个基本概念
### @Inject
用于构造一个这个类的实例并满足他们的依赖
### @Module
用```Module```标注的类是专门用来提供依赖的，作为实例对象的容器，无法修改的第三方```Jar```
### @Provide 
在```modules```中使用，标注能够提供实例化对象的方法
### @Component
```@Inject```和```@Module```的桥梁，它的主要作用就是连接这两个部分

## 四、更多概念

上面把四个简单的注解的用法都讲完了，但很多时候这几个注解并不能涵盖我们所有的场景，比如我们的类有多个构造方法，比如我们需要管理生命周期

### @Qulifier
当我们的类有多个构造方法，前面的```@Provide```就会蒙蔽了，于是需要```Qulifier```来解决，通过自定义```Qulifier```，可以去查找具体的依赖提供者
### @Scope & @Singleton
```Scope```提供局部单例的功能，所谓局部，就是在一定的生命周期内，比如```Application```、```Activity```，```Singleton```是```Scope```的一个实例，我们可以通过```Scope```创建属于自己的异域理解局部单例
### Lazy
通过申明，注入```Lazy```变量，实现懒加载，即在需要的时候才创建